# 0386.字典序排数

难度: 中等

给你一个整数 `n` ，按字典序返回范围 `[1, n]` 内所有整数。

你必须设计一个时间复杂度为 `O(n)` 且使用 `O(1)` 额外空间的算法。

 

**示例 1：**

```
输入：n = 13
输出：[1,10,11,12,13,2,3,4,5,6,7,8,9]
```

**示例 2：**

```
输入：n = 2
输出：[1,2]
```

 

**提示：**

- `1 <= n <= 5 * 104`

- 给你一个整数 `n` ，按字典序返回范围 `[1, n]` 内所有整数。

  你必须设计一个时间复杂度为 `O(n)` 且使用 `O(1)` 额外空间的算法。

   

  **示例 1：**

  ```
  输入：n = 13
  输出：[1,10,11,12,13,2,3,4,5,6,7,8,9]
  ```

  **示例 2：**

  ```
  输入：n = 2
  输出：[1,2]
  ```

   

  **提示：**

  - `1 <= n <= 5 * 104`

## Python

1. 模拟

   ```python
   # 1. O(n) t:44ms(98%) O(1) m:18.6M(94%) 模拟
   def lexicalOrder(self, n: int) -> List[int]:
       ans = []
       cur, cnt = 1, 1
       while cnt <= n:
           while cur * 10 <= n:
               ans.append(cur)
               cur *= 10
               cnt += 1
           else:
               diff = min(n - cur, 9 - cur % 10)
               for i in range(cur, cur + diff + 1):
                   ans.append(i)
                   cnt += 1
           while (cur // 10 + 1) % 10 == 0:
               cur //= 10
           cur = cur // 10 + 1
       return ans
   ```

## 小结

模拟题, 规律挺容易找的