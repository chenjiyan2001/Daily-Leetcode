# 0978.最长湍流子数组

难度: 中等



给定一个整数数组 `arr` ，返回 `arr` 的 *最大湍流子数组的**长度*** 。

如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是 **湍流子数组** 。

更正式地来说，当 `arr` 的子数组 `A[i], A[i+1], ..., A[j]` 满足仅满足下列条件时，我们称其为*湍流子数组*：

- 若 

  ```
  i <= k < j
  ```

   ：

  - 当 `k` 为奇数时， `A[k] > A[k+1]`，且
  - 当 `k` 为偶数时，`A[k] < A[k+1]`；

- 或 

  若 

  ```
  i <= k < j
  ```

   ：

  - 当 `k` 为偶数时，`A[k] > A[k+1]` ，且
  - 当 `k` 为奇数时， `A[k] < A[k+1]`。

 

**示例 1：**

```
输入：arr = [9,4,2,10,7,8,8,1,9]
输出：5
解释：arr[1] > arr[2] < arr[3] > arr[4] < arr[5]
```

**示例 2：**

```
输入：arr = [4,8,12,16]
输出：2
```

**示例 3：**

```
输入：arr = [100]
输出：1
```

 

**提示：**

- `1 <= arr.length <= 4 * 104`
- `0 <= arr[i] <= 109`

## Python

1. 两次遍历

   ```python
   # 1. O(n) t:172ms(51%) O(1) m:17.8M(69%) 两次遍历
   def maxTurbulenceSize(self, arr: List[int]) -> int:
       ans, cur = 0, 1
       for i in range(len(arr)-1):
           if arr[i] < arr[i+1] and i % 2 == 0:
               cur += 1
           elif arr[i] > arr[i+1] and i % 2 == 1:
               cur += 1
           else:
               ans = max(ans, cur)
               cur = 1
       ans = max(ans, cur)
       cur = 1
       for i in range(len(arr) - 1):
           if arr[i] < arr[i+1] and i % 2 == 1:
               cur += 1
           elif arr[i] > arr[i+1] and i % 2 == 0:
               cur += 1
           else:
               ans = max(ans, cur)
               cur = 1
       ans = max(ans, cur)
       return ans
   ```

2. 一次遍历

   ```python
   # 2. O(n) t:128ms(82%) O(1) m:17.9M(61%) 一次遍历
   def maxTurbulenceSize(self, arr: List[int]) -> int:
       ans, cur1, cur2 = 0, 1, 1
       for i in range(len(arr)-1):
           if arr[i] < arr[i+1]:
               if i % 2 == 0:
                   cur1 += 1
                   ans = max(ans, cur2)
                   cur2 = 1
               else:
                   ans = max(ans, cur1)
                   cur1 = 1
                   cur2 += 1
           elif arr[i] > arr[i+1]:
               if i % 2 == 1:
                   cur1 += 1
                   ans = max(ans, cur2)
                   cur2 = 1
               else:
                   ans = max(ans, cur1)
                   cur1 = 1
                   cur2 += 1
           else:
               ans = max(ans, cur1, cur2)
               cur1, cur2 = 1, 1
       ans = max(ans, cur1, cur2)
       return ans 
   ```

3. DP

   ```python
   # [题解]3. O(n) t:192ms(34%) O(n) m:20.2M(5%) DP
   def maxTurbulenceSize(self, arr: List[int]) -> int:
       n, ans = len(arr), 1
       dp = [[1, 1] for _ in range(n)]
       for i in range(1, n):
           if arr[i] > arr[i-1]:
               dp[i][0] = dp[i-1][1] + 1
           elif arr[i] < arr[i-1]:
               dp[i][1] = dp[i-1][0] + 1
           ans = max(ans, dp[i][0], dp[i][1])
       return ans
   ```

   

4. [题解]DP+奇偶滚动

   ```python
   # [题解]4. O(n) t:200ms(24%) O(1) m:17.8M(74%) DP+奇偶滚动
   def maxTurbulenceSize(self, arr: List[int]) -> int:
       n, ans = len(arr), 1
       dp = [[1, 1] for _ in range(2)]
       for i in range(1, n):
           dp[i % 2][0] = dp[i % 2][1] = 1
           if arr[i] > arr[i-1]:
               dp[i % 2][0] = dp[(i - 1) % 2][1] + 1
           elif arr[i] < arr[i-1]:
               dp[i % 2][1] = dp[(i - 1) % 2][0] + 1
           ans = max(ans, dp[i % 2][0], dp[i % 2][1])
       return ans
   ```

4. [题解]DP+维度消除

   ```python
   # [题解]5. O(n) t:160ms(59%) O(1) m:17.8M(82%) DP+维度消除
   def maxTurbulenceSize(self, arr: List[int]) -> int:
       n, ans = len(arr), 1
       dp = [1, 1]
       for i in range(1, n):
           a, b = dp
           dp[0] = (b + 1) if arr[i] > arr[i-1] else 1
           dp[1] = (a + 1) if arr[i] < arr[i-1] else 1
           ans = max(ans, dp[0], dp[1])
       return ans
   ```

   

## 小结

五月DP打卡Day1. DP入门题, 学习了一维DP的空间优化方法`奇偶滚动`和``维度消除``