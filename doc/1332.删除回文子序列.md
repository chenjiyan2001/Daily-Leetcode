# 1332.删除回文子序列

难度: 简单 | [题目入口]() | [官方题解]()

给你一个字符串 `s`，它仅由字母 `'a'` 和 `'b'` 组成。每一次删除操作都可以从 `s` 中删除一个回文 **子序列**。

返回删除给定字符串中所有字符（字符串为空）的最小删除次数。

「子序列」定义：如果一个字符串可以通过删除原字符串某些字符而不改变原字符顺序得到，那么这个字符串就是原字符串的一个子序列。

「回文」定义：如果一个字符串向后和向前读是一致的，那么这个字符串就是一个回文。

 

**示例 1：**

```
输入：s = "ababa"
输出：1
解释：字符串本身就是回文序列，只需要删除一次。
```

**示例 2：**

```
输入：s = "abb"
输出：2
解释："abb" -> "bb" -> "". 
先删除回文子序列 "a"，然后再删除 "bb"。
```

**示例 3：**

```
输入：s = "baabb"
输出：2
解释："baabb" -> "b" -> "". 
先删除回文子序列 "baab"，然后再删除 "b"。
```

 

**提示：**

- `1 <= s.length <= 1000`
- `s` 仅包含字母 `'a'` 和 `'b'`

## 分析

题目中给了「子序列」的定义：如果一个字符串可以通过删除原字符串某些字符而不改变原字符顺序得到，那么这个字符串就是原字符串的一个子序列。注意这里是``子序列``而非``子串``, 不要求连续, 所以可以先把a删完再删b, 因此最多只需要2次即可全部删完. 说实话蛮离谱的...

## Python

1. 字符串

   ```python
   # 1. O(n) t:28ms(85%) O(n) m:15.1M(10%)
   def removePalindromeSub(self, s: str) -> int:
       return 1 if s == s[::-1] else 2
   ```

2. 双指针

   ```python
   # 2. O(n) t:32ms(65%) O(1) m:15.1M(6%)
   def removePalindromeSub(self, s: str) -> int:
       for i in range(len(s)//2):
           if s[i] != s[len(s)-1-i]:
               return 2
       return 1
   ```

## Java

1. 双指针

   ```java
   // 1. O(n) t:0ms O(1) m:36.2M(53%)
   public int removePalindromeSub(String s) {
       int n = s.length();
       for (int i = 0; i <= n / 2; i++){
           if (s.charAt(i) != s.charAt(n - i - 1)) return 2;
       }
       return 1;
   }
   ```

   